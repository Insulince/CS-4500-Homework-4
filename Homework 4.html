<!-- Charles Justin Reusnow • 25 September 2017 • CMP SCI 4500 • Homework 4 -->
<!-- You can find my opening comment at the beginning of the script tag in the head of the HTML document described below. -->

<!DOCTYPE html>
<html>
<head>
    <title>A Pretty Strange Game</title>

    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <style>
        * {
            font-family: monospace;
        }

        .center-me {
            text-align: center;
        }

        .no-margin {
            margin: 0;
        }
    </style>
    <script>
        //Charles Justin Reusnow • 25 September 2017 • CMP SCI 4500 • Homework 4
        //My partners are, TODO however we did not discuss Homework 2 and instead spent all our time on the "blobs" in-class assignment.

        /* OPENING COMMENT.
         * The following code is my attempt to develop a solution to the specification provided in "Homework 2". I wrote it with modularity and clarity in mind, I believe I succeeded in these efforts because I found when skimming through the
         * code that I didn't need to put many clarification comments, for either the code was too short to be considered complex, or the code was named in such aa way that simply reading it led to an intuitive idea of what it was trying to do, though perhaps I am
         * unintentionally biased because I wrote it, so I have a better internal understanding of it. Aside from these two efforts, I believe it more importantly does exactly what the specification is asking, and I asked for clarification on most things during class,
         * though I do believe there were a few spots for ambiguity, and in these cases I stated what I thought to be the case under the "assumptions" section of the paragraph comment above the function containing the ambiguity. At about 700 lines of code, I believe I
         * may have gone a bit over board with this introductory project, but I prefer to do things thoroughly when possible, and this was too good an opportunity. I hope you find that this code meets your expectations for this homework. */

        /* GLOBAL ASSUMPTIONS.
         * Any function which references the "game" variable, other than the function "resetGame", expects it to be defined as a global variable, and as a copy of "EMPTY_GAME" with varying levels of defined values.
         * A move that would put the marker off of the grid leads to the marker being put back where it was AND still triggers a touch inside the cell the marker started in (and was then put back onto). */

        /* COMMON ASSUMPTIONS.
         * I found myself writing some of the same assumptions repeatedly, so I decided to write shorthand identifiers for them and just use the identifier to reference the concept in the assumptions section.
         * #A = The function "setupGame" was already called.
         * #B = "move" is an object composed of at least "direction" and "distance" members, where "direction" contains a value belonging to the "DIRECTIONS" array and "distance" contains a value belonging to the "DISTANCES" array.
         * #C = "position" is an object composed of at least "row" and "column" members, where "row" and "column" are both whole numbers. */

        "use strict"; //Strict mode used for better debugging and coding standards.

        google.charts.load('current', {'packages': ['corechart', 'bar']});

        function drawChart(container, averageTotalTouchesForNotHyper, averageTotalTouchesForHyper) {
            let data = new google.visualization.DataTable();

            data.addColumn('string', 'Hyper or Not');
            data.addColumn('number', 'Average Total Touches');

            data.addRows(
                [
                    [
                        "Not Hyper",
                        averageTotalTouchesForNotHyper
                    ],
                    [
                        "Hyper",
                        averageTotalTouchesForHyper
                    ]
                ]
            );

            let options = {
                height: 200,
                legend: {
                    position: "none"
                }
            };

            new google.charts.Bar(document.getElementById(container)).draw(data, options);

            let row = (experiment.parameters.numRows - 3) / 2;
            let col = (experiment.parameters.numCols - 3) / 2;

            console.log("row-" + row + "-col-" + col + "-results");

            document.getElementById("row-" + row + "-col-" + col + "-results").innerHTML = `
                <p>Average total touches for Non-Hyper grid: ` + averageTotalTouchesForNotHyper + `</p>
                <p>Average total touches for Hyper grid: ` + averageTotalTouchesForHyper + `</p>
                <p>The Hyper grid took ` + (averageTotalTouchesForHyper >= averageTotalTouchesForNotHyper ? "more or just as many" : "less") + ` total touches on average than the Non-Hyper grid.</p>
            `;
        }

        //CONSTANTS.
        //There are so many constants because these are the things I would put in a config file for easy tweaking of the parameters of the program.

        //These are basically type definitions, they get copied into objects that are to take on this form of object later.
        const EMPTY_GRID = [];
        const EMPTY_ROW = [];
        const EMPTY_COLUMN = 0;
        const EMPTY_POSITION = {
            "row": undefined,
            "column": undefined
        };
        const EMPTY_MOVE = {
            "direction": undefined,
            "distance": undefined
        };
        const EMPTY_GAME = {
            "parameters": {
                "hyper": undefined,
                "rowQuantity": undefined,
                "columnQuantity": undefined,
                "winningPositionIsAtBottomRightCorner": undefined
            },
            "grid": undefined,
            "marker": {
                "position": {
                    "row": undefined,
                    "column": undefined
                }
            },
            "touches": 0,
            "results": {
                "maximumTouches": undefined,
                "minimumTouches": undefined,
                "averageTouchesPerCell": undefined,
                "outcome": undefined,
                "totalTouches": undefined
            }
        };
        const EMPTY_EXPERIMENT = {
            "trials": [],
            "parameters": {
                "quantityTrials": {
                    "notHyper": undefined,
                    "hyper": undefined
                },
                "numRows": undefined,
                "numCols": undefined,
                "container": undefined
            }
        };
        const EMPTY_TRIAL = {
            "independentVariableValue": undefined,
            "dependentVariableValue": undefined
        };

        const MAXIMUM_TOUCHES_ALLOWED = 1000000;

        const NOT_HYPER = false;
        const HYPER = true;

        //ENUMS.
        //Direction Enum.
        const DIRECTION_LEFT = 0;
        const DIRECTION_UP = 1;
        const DIRECTION_RIGHT = 2;
        const DIRECTION_DOWN = 3;
        const DIRECTIONS = [DIRECTION_LEFT, DIRECTION_UP, DIRECTION_RIGHT, DIRECTION_DOWN];
        const DIRECTION_QUANTITY = DIRECTIONS.length;

        //Distance Enum.
        const DISTANCE_ZERO = 0;
        const DISTANCE_ONE = 1;
        const DISTANCE_TWO = 2;
        const DISTANCES = [DISTANCE_ZERO, DISTANCE_ONE, DISTANCE_TWO];
        const DISTANCE_QUANTITY = DISTANCES.length;

        //End Game Enum.
        const GAME_SUCCESS = true;
        const GAME_FAILURE = false;

        //The global experiment object.
        let experiment = undefined;

        //The global game object.
        let game = undefined;

        resetGame();

        /* Purpose: Entry point to the rest of the logic of this game, it is triggered when the user clicks the "Play New Game" button.
         * Inputs: None.
         * Output: None.
         * Assumptions: None. */
        function playNewGame(hyper, parameters) {
            resetGame();
            setupGame(hyper, parameters);
            playGame();
            calculateResults();

            let trial = deepCopy(EMPTY_TRIAL);
            trial.independentVariableValue = hyper === true ? "Hyper" : "Not Hyper";
            trial.dependentVariableValue = game.results.totalTouches;
            experiment.trials.push(trial);
        }

        /* Purpose: Ensures the game always starts as a fresh game with no previous values carried over.
         * Inputs: None.
         * Output: None.
         * Assumptions: None. */
        function resetGame() {
            game = deepCopy(EMPTY_GAME);
        }

        /* Purpose: Takes an object and copies it to a brand new object to avoid passing by reference. This is accomplished by turning the object into a JSON string and then bringing it back to an object, thereby removing any references to a previous object.
         * Inputs: "object" - The entity you wish to deep copy.
         * Output: a completely separate copy of "object".
         * Assumptions: "object" is not a self-referential object, nor an object which leads to circular references. Failure to adhere to these assumptions leads to JSON.stringify failing. */
        function deepCopy(object) {
            return JSON.parse(JSON.stringify(object));
        }

        /* Purpose: Preforms initial setup of the game by creating the grid and placing the marker in the starting position.
         * Inputs: None.
         * Output: None.
         * Assumptions: The function "resetGame" was already called. */
        function setupGame(hyper, parameters) {
            game.parameters.hyper = hyper;
            game.parameters.rowQuantity = parameters.numRows;
            game.parameters.columnQuantity = parameters.numCols;
            game.parameters.winningPositionIsAtBottomRightCorner = parameters.winningPositionIsAtBottomRightCorner;

            createGrid(game.parameters.rowQuantity, game.parameters.columnQuantity);
            placeMarkerAndRecordTouchAt(0, 0);
        }

        /* Purpose: Creates the grid for the game.
         * Inputs:
         * • "rowQuantity" - The number of rows to put in this grid.
         * • "columnQuantity" - The number of columns to put in this grid.
         * Output: None.
         * Assumptions: Inputs are all natural numbers. */
        function createGrid(rowQuantity, columnQuantity) {
            resetGrid();
            addRowsAndColumnsToGrid(rowQuantity, columnQuantity);
        }

        /* Purpose: Clears the game's grid object to ensure there is no left over values from a previous game.
         * Inputs: None.
         * Output: None.
         * Assumptions: None. */
        function resetGrid() {
            game.grid = deepCopy(EMPTY_GRID);
        }

        /* Purpose: Adds the rows and columns to the game's grid object.
         * Inputs:
         * • "rowQuantity" - The number of rows to put in this grid.
         * • "columnQuantity" - The number of columns to put in this grid.
         * Output: None.
         * Assumptions: Inputs are all natural numbers. */
        function addRowsAndColumnsToGrid(rowQuantity, columnQuantity) {
            for (let rowIndex = 0; rowIndex < rowQuantity; rowIndex++) {
                addNewRow();
                addColumnsToRow(rowIndex, columnQuantity);
            }
        }

        /* Purpose: Adds a new row to the game's grid object.
         * Inputs: None.
         * Output: None.
         * Assumptions: "game.grid" is an array. */
        function addNewRow() {
            game.grid.push(deepCopy(EMPTY_ROW));
        }

        /* Purpose: Adds all the columns to the game's grid object's current row.
         * Inputs:
         * • "rowIndex" - The current row of the grid which we are filling with columns.
         * • "columnQuantity" - The number of columns to put in this row.
         * Output: None.
         * Assumptions: "rowIndex" is a whole number, "columnQuantity" is a natural number. */
        function addColumnsToRow(rowIndex, columnQuantity) {
            for (let columnIndex = 0; columnIndex < columnQuantity; columnIndex++) {
                addNewColumnToRow(rowIndex);
            }
        }

        /* Purpose: Adds a new column to the game's grid object's current row.
         * Inputs: "rowIndex" - The current row of the grid which we are adding a column to.
         * Output: None.
         * Assumptions: "rowIndex" is a whole number, "game.grid[rowIndex]" is an array. */
        function addNewColumnToRow(rowIndex) {
            game.grid[rowIndex].push(deepCopy(EMPTY_COLUMN));
        }

        /* Purpose: Places the marker at the provided row and column, and records the touch it creates in being placed.
         * Inputs:
         * • "row" - The row to place the marker and record the touch at.
         * • "column" - The column to place the marker and record the touch at.
         * Output: None.
         * Assumptions: Inputs are all whole numbers. */
        function placeMarkerAndRecordTouchAt(row, column) {
            placeMarkerAt(row, column);
            recordTouchAt(row, column);
        }

        /* Purpose: Places the marker at the provided row and column.
         * Inputs:
         * • "row" - The row to place the marker at.
         * • "column" - The column to place the marker at.
         * Output: None.
         * Assumptions: Inputs are all whole numbers. */
        function placeMarkerAt(row, column) {
            game.marker.position.row = row;
            game.marker.position.column = column;
        }

        /* Purpose: Records the touch at the provided row and column, and also in the running total.
         * Inputs:
         * • "row" - The row to record the touch at.
         * • "column" - The column to record the touch at.
         * Output: None.
         * Assumptions: Inputs are all whole numbers. */
        function recordTouchAt(row, column) {
            incrementTotalTouches();
            incrementTouchCountAt(row, column);
        }

        /* Purpose: Increments the game's total touches.
         * Inputs: None.
         * Output: None.
         * Assumptions: "game.touches" is an integer. */
        function incrementTotalTouches() {
            game.touches++;
        }

        /* Purpose: Increments the game's grid object's touch count at the provided row and column.
         * Inputs:
         * • "row" - The row to record the touch at.
         * • "column" - The column to record the touch at.
         * Output: None.
         * Assumptions: Inputs are all whole numbers and "game.grid[row][column] is an integer. */
        function incrementTouchCountAt(row, column) {
            game.grid[row][column]++;
        }

        /* Purpose: Plays the game based on the interval the user entered under the "speed" parameter.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function playGame() {
            while (shouldContinuePlayingGame()) {
                continuePlayingGame();
            }
        }

        /* Purpose: Determines whether the game is over or if it should continue playing. This is determined by checking if the win condition (marker is in winning position) or lose condition (too many moves) has been met.
         * Inputs: None.
         * Output: A boolean indicating whether the game should continue playing or not.
         * Assumptions: #A. */
        function shouldContinuePlayingGame() {
            return !gameIsWon() && !gameIsBeyondMaximumTouches();
        }

        /* Purpose: Determines whether the game has been won or not.
         * Inputs: None.
         * Output: A boolean indicating whether the game has been won or not.
         * Assumptions: #A. */
        function gameIsWon() {
            return markerIsInWinningPosition();
        }

        /* Purpose: Determines whether the marker is in the winning position or not.
         * Inputs: None.
         * Output: A boolean indicating whether the marker is in the winning position or not.
         * Assumptions: #A. */
        function markerIsInWinningPosition() {
            return markerIsInWinningRow() && markerIsInWinningColumn();
        }

        /* Purpose: Determines whether the marker is in the winning row or not.
         * Inputs: None.
         * Output: A boolean indicating whether the marker is in the winning row or not.
         * Assumptions: #A. */
        function markerIsInWinningRow() {
            if (game.parameters.winningPositionIsAtBottomRightCorner) {
                return game.marker.position.row === game.parameters.rowQuantity - 1;
            } else {
                return game.marker.position.row === Math.floor(game.parameters.rowQuantity / 2);
            }
        }

        /* Purpose: Determines whether the marker is in the winning column or not.
         * Inputs: None.
         * Output: A boolean indicating whether the marker is in the winning column or not.
         * Assumptions: #A. */
        function markerIsInWinningColumn() {
            if (game.parameters.winningPositionIsAtBottomRightCorner) {
                return game.marker.position.column === game.parameters.columnQuantity - 1;
            } else {
                return game.marker.position.column === Math.floor(game.parameters.columnQuantity / 2);
            }
        }

        /* Purpose: Determines whether the game has surpassed the maximum amount of touches or not.
         * Inputs: None.
         * Output: A boolean indicating whether the game has surpassed the maximum amount of touches or not.
         * Assumptions: #A. */
        function gameIsBeyondMaximumTouches() {
            return game.touches >= MAXIMUM_TOUCHES_ALLOWED;
        }

        /* Purpose: Run the game through another iteration. Each iteration is composed of generating a move, recording the marker's original position, determining if the generated move is valid, and moving the marker accordingly.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function continuePlayingGame() {
            let move = generateRandomMove();
            let originalMarkerLocation = deepCopy(game.marker.position);

            if (!game.parameters.hyper) {
                if (thisMoveDoesNotPutMarkerOutsideOfGrid(move)) {
                    placeMarkerAtPositionFromMove(move);
                } else {
                    placeMarkerAtOriginalLocation(originalMarkerLocation);
                }
            } else {
                placeMarkerAtHyperPositionFromMove(move);
            }

            calculateRunningResults();
        }

        /* Purpose: Creates a random move to apply to the marker.
         * Inputs: None.
         * Output: A randomly generated move.
         * Assumptions: None. */
        function generateRandomMove() {
            let move = deepCopy(EMPTY_MOVE);

            move.direction = generateRandomDirection();
            move.distance = generateRandomDistance();

            return move;
        }

        /* Purpose: Selects a random direction from the direction array.
         * Inputs: None.
         * Output: A randomly chosen direction from the direction array.
         * Assumptions: None. */
        function generateRandomDirection() {
            return DIRECTIONS[getRandomIntegerBetween(0, DIRECTION_QUANTITY)];
        }

        /* Purpose: Creates a random integer between two values.
         * Inputs:
         * • "lowerBound" - A number indicating the inclusive lower bound for the range of random integers to generate.
         * • "upperBound" - A number indicating the inclusive upper bound for the range of random integers to generate.
         * Output: A random integer that falls between "lowerBound" and "upperBound" inclusive.
         * Assumptions: Inputs are all integers. "lowerBound" <= "upperBound". */
        function getRandomIntegerBetween(lowerBound, upperBound) {
            return lowerBound + Math.floor(Math.random() * upperBound)
        }

        /* Purpose: Selects a random distance from the distance array.
         * Inputs: None.
         * Output: A randomly chosen distance from the distance array.
         * Assumptions: None. */
        function generateRandomDistance() {
            return DISTANCES[getRandomIntegerBetween(0, DISTANCE_QUANTITY)];
        }

        /* Purpose: Determines whether the provided move would put the marker outside of the grid or not. This is accomplished by getting the position the marker would be in if the provided move were applied, then checking if that position is in the grid still.
         * Inputs: "move" - The move object containing both a direction and a distance.
         * Output: A boolean indicating whether the provided move would put the marker outside of the grid or not.
         * Assumptions: #A. #B. */
        function thisMoveDoesNotPutMarkerOutsideOfGrid(move) {
            let potentialNewMarkerPosition = getMarkerPositionAfterThisMove(move);
            return positionIsWithinGrid(potentialNewMarkerPosition);
        }

        /* Purpose: Determines whether the provided position is within the grid or not. This is accomplished by checking all four bounds of the gird for any breaches.
         * Inputs: "position" - The position object containing both a row and a column.
         * Output: A boolean indicating whether the provided position is within the grid.
         * Assumptions: #C. */
        function positionIsWithinGrid(position) {
            return positionIsWithinLeftBound(position) && positionIsWithinTopBound(position) && positionIsWithinRightBound(position) && positionIsWithinBottomBound(position); //If the position is within all four bounds of the grid, return true, else return false.
        }

        /* Purpose: Determines whether the provided position is within the left bound of the grid.
         * Inputs: "position" - The position object containing both a row and a column.
         * Output: A boolean indicating whether the provided position is within the left bound of the grid.
         * Assumptions: #C. */
        function positionIsWithinLeftBound(position) {
            return position.column >= 0;
        }

        /* Purpose: Determines whether the provided position is within the top bound of the grid.
         * Inputs: "position" - The position object containing both a row and a column.
         * Output: A boolean indicating whether the provided position is within the top bound of the grid.
         * Assumptions: #C. */
        function positionIsWithinTopBound(position) {
            return position.row >= 0;
        }

        /* Purpose: Determines whether the provided position is within the right bound of the grid.
         * Inputs: "position" - The position object containing both a row and a column.
         * Output: A boolean indicating whether the provided position is within the right bound of the grid.
         * Assumptions: #C. */
        function positionIsWithinRightBound(position) {
            return position.column <= game.parameters.columnQuantity - 1;
        }

        /* Purpose: Determines whether the provided position is within the bottom bound of the grid.
         * Inputs: "position" - The position object containing both a row and a column.
         * Output: A boolean indicating whether the provided position is within the bottom bound of the grid.
         * Assumptions: #C. */
        function positionIsWithinBottomBound(position) {
            return position.row <= game.parameters.rowQuantity - 1;
        }

        /* Purpose: Gets the position of the marker after the provided move is applied to it.
         * Inputs: "move" - The move object containing both a direction and a distance.
         * Output: A position object containing a row and column fields which correspond to the position the marker would be in, should the provided move object be applied to it.
         * Assumptions: #A. #B. Failure to adhere to assumption #B leads to the default case of the switch statement executing which leads to an error being thrown. */
        function getMarkerPositionAfterThisMove(move) {
            let markerPositionAfterThisMove = deepCopy(EMPTY_POSITION);

            switch (move.direction) {
                case DIRECTION_LEFT: //If the move direction is up...
                    markerPositionAfterThisMove.row = game.marker.position.row;
                    markerPositionAfterThisMove.column = game.marker.position.column - getMoveDistance(move); //Subtract across the columns to go left.
                    break;
                case DIRECTION_UP: //If the move direction is left...
                    markerPositionAfterThisMove.row = game.marker.position.row - getMoveDistance(move); //Subtract across the rows to go up.
                    markerPositionAfterThisMove.column = game.marker.position.column;
                    break;
                case DIRECTION_RIGHT: //If the move direction is down...
                    markerPositionAfterThisMove.row = game.marker.position.row;
                    markerPositionAfterThisMove.column = game.marker.position.column + getMoveDistance(move); //Advance across the columns to go right.
                    break;
                case DIRECTION_DOWN: //If the move direction is right...
                    markerPositionAfterThisMove.row = game.marker.position.row + getMoveDistance(move); //Advance across the rows to go down.
                    markerPositionAfterThisMove.column = game.marker.position.column;
                    break;
                default:
                    throw new Error("Unrecognized move direction encountered: \"" + move.direction + "\".");
            }

            return markerPositionAfterThisMove;
        }

        function getMarkerPositionAfterThisHyperMove(move) {
            let markerPositionAfterThisMove = deepCopy(EMPTY_POSITION);

            switch (move.direction) {
                case DIRECTION_LEFT: //If the move direction is up...
                    markerPositionAfterThisMove.row = game.marker.position.row;
                    if (game.marker.position.column - getMoveDistance(move) >= 0) {
                        markerPositionAfterThisMove.column = game.marker.position.column - getMoveDistance(move); //Subtract across the columns to go left.
                    } else {
                        markerPositionAfterThisMove.column = game.parameters.columnQuantity - Math.abs(game.marker.position.column - getMoveDistance(move));
                    }
                    break;
                case DIRECTION_UP: //If the move direction is left...
                    if (game.marker.position.row - getMoveDistance(move) >= 0) {
                        markerPositionAfterThisMove.row = game.marker.position.row - getMoveDistance(move); //Subtract across the rows to go up.
                    } else {
                        markerPositionAfterThisMove.row = game.parameters.rowQuantity - Math.abs(game.marker.position.row - getMoveDistance(move));
                    }
                    markerPositionAfterThisMove.column = game.marker.position.column;
                    break;
                case DIRECTION_RIGHT: //If the move direction is down...
                    markerPositionAfterThisMove.row = game.marker.position.row;
                    if (game.marker.position.column + getMoveDistance(move) < game.parameters.columnQuantity) {
                        markerPositionAfterThisMove.column = game.marker.position.column + getMoveDistance(move); //Advance across the columns to go right.
                    } else {
                        markerPositionAfterThisMove.column = game.marker.position.column + getMoveDistance(move) - game.parameters.columnQuantity;
                    }
                    break;
                case DIRECTION_DOWN: //If the move direction is right...
                    if (game.marker.position.row + getMoveDistance(move) < game.parameters.rowQuantity) {
                        markerPositionAfterThisMove.row = game.marker.position.row + getMoveDistance(move); //Advance across the rows to go down.
                    } else {
                        markerPositionAfterThisMove.row = game.marker.position.row + getMoveDistance(move) - game.parameters.rowQuantity;
                    }
                    markerPositionAfterThisMove.column = game.marker.position.column;
                    break;
                default:
                    throw new Error("Unrecognized move direction encountered: \"" + move.direction + "\".");
            }

            return markerPositionAfterThisMove;
        }

        /* Purpose: Gets the distance as a number represented in the provided move object.
         * Inputs: "move" - The move object containing both a direction and a distance.
         * Output: The distance as an integer that the move object contains.
         * Assumptions: #B. Failure to adhere to assumption #B leads to the default case of the switch statement executing which leads to an error being thrown. */
        function getMoveDistance(move) {
            let distance = undefined;

            switch (move.distance) {
                case DISTANCE_ZERO:
                    distance = 0;
                    break;
                case DISTANCE_ONE:
                    distance = 1;
                    break;
                case DISTANCE_TWO:
                    distance = 2;
                    break;
                default:
                    throw new Error("Unrecognized move distance encountered: \"" + move.distance + "\".");
            }

            return distance;
        }

        /* Purpose: Puts the marker at its new position after the provided move is applied to it.
         * Inputs: "move" - The move object containing both a direction and a distance.
         * Output: None.
         * Assumptions: #B. The function "getMarkerPositionAfterThisMove" returns a valid position object, resembling the object described in #C. */
        function placeMarkerAtPositionFromMove(move) {
            let newMarkerPosition = getMarkerPositionAfterThisMove(move);
            placeMarkerAndRecordTouchAt(newMarkerPosition.row, newMarkerPosition.column);
        }

        function placeMarkerAtHyperPositionFromMove(move) {
            let newMarkerPosition = getMarkerPositionAfterThisHyperMove(move);
            placeMarkerAndRecordTouchAt(newMarkerPosition.row, newMarkerPosition.column);
        }

        /* Purpose: Puts the marker at its original position because the move generated earlier would put the marker off the grid.
         * Inputs: "originalMarkerLocation" - A position object containing the original position of the marker before a move is executed.
         * Output: None.
         * Assumptions: "originalMarkerLocation" resembles the object described in #C. */
        function placeMarkerAtOriginalLocation(originalMarkerLocation) {
            placeMarkerAndRecordTouchAt(originalMarkerLocation.row, originalMarkerLocation.column);
        }

        /* Purpose: Calculates the results of the game and stores them in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateResults() {
            calculateOutcome();
            calculateMaximumTouches();
            calculateMinimumTouches();
            calculateAverageTouchesPerCell();
            calculateTotalTouches();
        }

        /* Purpose: To calculate the running results (does not calculate the game's outcome, because it's still running).
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateRunningResults() {
            calculateMaximumTouches();
            calculateMinimumTouches();
            calculateAverageTouchesPerCell();
            calculateTotalTouches();
        }

        /* Purpose: Calculates the outcome of the game and stores it in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. The game has either reached a winning condition or has surpassed the maximum amount of touches allowed. Failure to adhere to the previous assumption leads to an error being thrown. */
        function calculateOutcome() {
            if (gameIsWon()) {
                game.results.outcome = GAME_SUCCESS;
            } else if (gameIsBeyondMaximumTouches()) {
                game.results.outcome = GAME_FAILURE;
            } else {
                throw new Error("Unexpected end of game encountered.");
            }
        }

        /* Purpose: Calculates the maximum touches of the game and stores it in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateMaximumTouches() {
            game.results.maximumTouches = findMaximumTouchesInGrid();
        }

        /* Purpose: Preforms the actual calculation of which cell had the most touches.
         * Inputs: None.
         * Output: The quantity of touches in the cell that has the most touches.
         * Assumptions: #A. */
        function findMaximumTouchesInGrid() {
            let maximumTouchedInGrid = 0;

            game.grid.forEach( //For each row in the grid...
                (row) => {
                    row.forEach( //For each column in this row...
                        (touchesInCell) => {
                            if (touchesInCell > maximumTouchedInGrid) { //If the touches in this cell is more than the maximum recorded...
                                maximumTouchedInGrid = touchesInCell; //The touches in this cell is the maximum, record that.
                            }
                        }
                    );
                }
            );

            return maximumTouchedInGrid;
        }

        /* Purpose: Calculates the minimum touches of the game and stores it in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateMinimumTouches() {
            game.results.minimumTouches = findMinimumTouchesInGrid();
        }

        /* Purpose: Preforms the actual calculation of which cell had the least touches.
         * Inputs: None.
         * Output: The quantity of touches in the cell that has the least touches.
         * Assumptions: #A. */
        function findMinimumTouchesInGrid() {
            let minimumTouchedInGrid = MAXIMUM_TOUCHES_ALLOWED;

            game.grid.forEach( //For each row in the grid...
                (row) => {
                    row.forEach( //For each column in this row...
                        (touchesInCell) => {
                            if (touchesInCell < minimumTouchedInGrid) { //If the touches in this cell is less than the minimum recorded...
                                minimumTouchedInGrid = touchesInCell; //The touches in this cell is the minimum, record that.
                            }
                        }
                    );
                }
            );

            return minimumTouchedInGrid;
        }

        /* Purpose: Calculates the average touches per cell of the game and stores it in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateAverageTouchesPerCell() {
            game.results.averageTouchesPerCell = findAverageTouchesPerCellInGrid();
        }

        /* Purpose: Preforms the actual calculation of the average touches per cell.
         * Inputs: None.
         * Output: The average quantity of touches across all cells in the grid as a decimal precise to 2 decimal places.
         * Assumptions: #A. "game.parameters.rowQuantity * game.parameters.columnQuantity" != 0. */
        function findAverageTouchesPerCellInGrid() {
            let totalTouches = 0;

            game.grid.forEach( //For each row in the grid...
                (row) => {
                    row.forEach( //For each column in this row...
                        (touchesInCell) => {
                            totalTouches += touchesInCell; //Add the touches in this cell to the total touches recorded so far.
                        }
                    );
                }
            );

            return (totalTouches / (game.parameters.rowQuantity * game.parameters.columnQuantity)).toFixed(2); //The average touches per cell is the total touches across all cells divided by how many cells there are.
        }

        /* Purpose: Calculates the total touches of the game and stores it in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateTotalTouches() {
            game.results.totalTouches = game.touches;
        }

        function doExperiment() {
            while (experiment.trials.length < experiment.parameters.quantityTrials.notHyper) {
                playNewGame(NOT_HYPER, experiment.parameters);
            }

            while (experiment.trials.length - experiment.parameters.quantityTrials.notHyper < experiment.parameters.quantityTrials.hyper) {
                playNewGame(HYPER, experiment.parameters);
            }

            let totalTouchesAcrossAllNotHyperTrials = 0;
            let totalTouchesAcrossAllHyperTrials = 0;
            experiment.trials.forEach(
                (trial) => {
                    if (trial.independentVariableValue === "Not Hyper") {
                        totalTouchesAcrossAllNotHyperTrials += trial.dependentVariableValue;
                    } else {
                        totalTouchesAcrossAllHyperTrials += trial.dependentVariableValue;
                    }
                }
            );

            console.log(experiment.parameters.container);
            drawChart(experiment.parameters.container, totalTouchesAcrossAllNotHyperTrials / experiment.parameters.quantityTrials.notHyper, totalTouchesAcrossAllHyperTrials / experiment.parameters.quantityTrials.hyper); //TODO
        }

        function runSingleExperiment(row, column) {
            let numRows = row * 2 + 3;
            let numCols = column * 2 + 3;

            experiment = deepCopy(EMPTY_EXPERIMENT);

            let quantityTrials = document.getElementById("quantity-trials").value;

            experiment.parameters.quantityTrials.notHyper = quantityTrials;
            experiment.parameters.quantityTrials.hyper = quantityTrials;

            experiment.parameters.winningPositionIsAtBottomRightCorner = $("#winning-position-is-at-bottom-right-corner").is(":checked");

            experiment.parameters.numRows = numRows;
            experiment.parameters.numCols = numCols;

            experiment.parameters.container = "row-" + row + "-col-" + column + "-graph";

            doExperiment();
        }

        function runExperiments() {
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    let numRows = i * 2 + 3;
                    let numCols = j * 2 + 3;

                    experiment = deepCopy(EMPTY_EXPERIMENT);

                    let quantityTrials = document.getElementById("quantity-trials").value;

                    experiment.parameters.quantityTrials.notHyper = quantityTrials;
                    experiment.parameters.quantityTrials.hyper = quantityTrials;

                    experiment.parameters.winningPositionIsAtBottomRightCorner = $("#winning-position-is-at-bottom-right-corner").is(":checked");

                    experiment.parameters.numRows = numRows;
                    experiment.parameters.numCols = numCols;

                    experiment.parameters.container = "row-" + i + "-col-" + j + "-graph";

                    doExperiment();
                }
            }
        }

        function loadExperimentCells() {
            let output = ``;

            for (let i = 0; i < 4; i++) {
                output += `
                    <div id="row-` + i + `" class="row">
                `;

                for (let j = 0; j < 4; j++) {
                    output += `
                        <div id="row-` + i + `-col-` + j + `" class="col-md-3">
                            <div class="experiment-cell panel panel-default">
                                <div class="panel-heading">
                                    <b style="margin: 0; display: inline">` + (i * 2 + 3) + ` Rows, ` + (j * 2 + 3) + ` Columns</b><button style="float: right" class="btn btn-success btn-xs" onclick="runSingleExperiment(` + i + `, ` + j + `)">Run</button>
                                </div>
                                <div class="panel-body">
                                    <div id="row-` + i + `-col-` + j + `-graph">Experiment not yet run.</div>
                                    <div id="row-` + i + `-col-` + j + `-results"></div>
                                </div>
                            </div>
                        </div>
                    `;
                }

                output += `
                    </div>
                `;
            }

            document.getElementById("experiment-wrapper").innerHTML = document.getElementById("experiment-wrapper").innerHTML + output;
        }
    </script>
</head>
<body onload="loadExperimentCells();">
<div class="container-fluid">
    <div class="row">
        <div id="content-wrapper" class="col-md-10 col-md-offset-1">
            <div class="row">
                <div class="col-md-10 col-md-offset-1">
                    <h1 class="center-me">A Pretty Strange Game</h1>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <div class="panel panel-default">
                        <div class="panel-heading center-me">
                            <h3 class="no-margin">Introduction</h3>
                        </div>
                        <div class="panel-body">
                            Below is an interface for testing a series of experiments against the strange game I have been developing. The experiment I had in mind is to test whether making the plane "Hyper" or not has an affect on the average number of maximum touches that the marker creates. In
                            this project I will be referring to "Hyper" as meaning that the plane that the marker resides in extends beyond the grid, in that if a marker chooses a move that would place it off the grid, it instead wraps around and lands back on the grid as if the grid were in the
                            shape of a torus. To put it explicitly, the Independent Variable is whether the game's grid is Hyper or not, and the Dependent Variable is the average number of maximum touches the marker creates. But this isn't strictly true because I have added a few controls to allow
                            varying of some other features. My motivation for doing this is that I wasn't satisfied with the results I was seeing so I wanted to expand my horizons to see if other factors could affect the degree to which my original experiment affected the game. So the true list of
                            Independent Variables is: Whether the game is Hyper or not, the size of the grid, and the position of the winning tile. I added in the ability to change the position of the winning tile because the following situation occurred to me: If the marker starts in the top left
                            corner, and the winning tile is the bottom right corner, and the grid is hyper, that means the marker could theoretically win in 2 moves (up 1, left 1) while the non-hyper marker would have a much longer time getting there. To fight this, I added the ability to move the
                            winning tile to the center of the grid (hence why all the test grids are odd numbered in terms of row and column quantity). You can also vary the quantity of trials per experiment, though I wouldn't consider this an independent variable, this is more for quality of the
                            experiment vs. time available to invest in the experiment. For optimal results that balance those two features, I suggest trying a quantity around 2500 (which leads to 40000 trials because there are 16 experiments). If you wish to run your configuration on one specific
                            grid size, that grid has its own run button to test just that one. And please note: <p style="color: red; display: inline">these experiments can take awhile if you use many trials, please be patient if you surpass the recommended trial quantity</p>.
                        </div>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="col-md-12">
                    <div class="panel panel-default">
                        <div class="panel-heading center-me">
                            <h3 class="no-margin">Experiments</h3>
                        </div>
                        <div class="panel-body" style="padding-bottom: 0;">
                            <div class="row">
                                <div class="col-md-12" style="margin-bottom: 20px;">
                                    <form class="form-inline" style="display: inline;">
                                        <label for="quantity-trials">Quantity Trials per Experiment</label>
                                        <input id="quantity-trials" class="form-control" type="number" min="1" value="100"/>
                                        Winning position is at:
                                        <label for="winning-position-is-at-bottom-right-corner">bottom right corner</label>
                                        <input id="winning-position-is-at-bottom-right-corner" type="radio" name="winning-position-is-at" value="bottom-right-corner" checked="checked"/>
                                        <label for="winning-position-is-at-center">center</label>
                                        <input id="winning-position-is-at-center" type="radio" name="winning-position-is-at" value="center"/>
                                    </form>
                                    <button class="btn btn-success" style="float: right" onclick="runExperiments(); return false;">Run All Experiments</button>
                                </div>
                            </div>
                            <div class="row">
                                <div id="experiment-wrapper" class="col-md-12"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
</html>
