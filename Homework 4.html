<!-- Charles Justin Reusnow • 1 September 2017 • CMP SCI 4500 • Homework 2 -->
<!-- You can find my opening comment at the beginning of the script tag in the head of the HTML document described below. -->

<!DOCTYPE html>
<html>
<head>
    <title>A Pretty Strange Game</title>

    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <style>
        .divider {
            text-align: center;
            margin-top: 20px;
        }

        .panel {
            background-color: #dddddd;
            border: 3px solid black;
            text-align: center;
            font-family: Consolas, serif;
            margin-left: auto;
            margin-right: auto;
            padding: 15px;
            display: inline-block;
        }

        .panel-title {
            margin: 0 0 10px;
        }

        .panel-subtitle {
            margin: 20px 0 10px;
        }

        #game-board {
            border: solid 1px black;
        }

        .row {
            margin: 0;
            padding: 0;
            line-height: 0;
        }

        .column {
            padding: 0;
            margin: 0;
            line-height: 0;
            min-height: 34px;
            min-width: 34px;
            border: solid 1px black;
            display: inline-block;
        }

        .column-even-even, .column-odd-odd {
            background-color: #888888;
        }

        .column-even-odd, .column-odd-even {
            background-color: #e7e7e7;
        }

        #marker {
            position: relative;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            width: 32px;
            height: 32px;
            border: solid darkred 1px;
            border-radius: 50%;
            background-color: red;
        }

        .marker-off {
            position: relative;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            width: 32px;
            height: 32px;
            border: 1px solid rgba(0, 0, 0, 0);
        }

        .cell-content {
            position: absolute;
            top: 5px;
            left: 2px;
            margin: 0;
            padding: 0;
            font-size: 10px;
            color: darkgrey;
        }

        #play-new-game-button {
            padding: 16px 32px;
            display: block;
            font-size: 14px;
            font-weight: bolder;
            background-color: #bbbbbb;
            border: 3px solid black;
            margin-top: 20px;
            margin-left: auto;
            margin-right: auto;
        }

        #parameters-table, #parameters-table tr, #parameters-table tr th, #parameters-table tr td, #last-move-description-table, #last-move-description-table tr, #last-move-description-table tr th, #last-move-description-table tr td, #results-table, #results-table tr, #results-table tr th, #results-table tr td {
            padding: 5px;
            border: 3px solid black;
            border-collapse: collapse;
            background-color: #e7e7e7;
        }

        .center-me {
            text-align: center;
        }

        .parameter-input {
            width: 97%;
        }
    </style>
    <script>
        //Charles Justin Reusnow • 1 September 2017 • CMP SCI 4500 • Homework 2
        //My partner was Yehuda, however we did not discuss Homework 2 and instead spent all our time on the "blobs" in-class assignment.

        /* OPENING COMMENT.
         * The following code is my attempt to develop a solution to the specification provided in "Homework 2". I wrote it with modularity and clarity in mind, I believe I succeeded in these efforts because I found when skimming through the
         * code that I didn't need to put many clarification comments, for either the code was too short to be considered complex, or the code was named in such aa way that simply reading it led to an intuitive idea of what it was trying to do, though perhaps I am
         * unintentionally biased because I wrote it, so I have a better internal understanding of it. Aside from these two efforts, I believe it more importantly does exactly what the specification is asking, and I asked for clarification on most things during class,
         * though I do believe there were a few spots for ambiguity, and in these cases I stated what I thought to be the case under the "assumptions" section of the paragraph comment above the function containing the ambiguity. At about 700 lines of code, I believe I
         * may have gone a bit over board with this introductory project, but I prefer to do things thoroughly when possible, and this was too good an opportunity. I hope you find that this code meets your expectations for this homework. */

        /* GLOBAL ASSUMPTIONS.
         * Any function which references the "game" variable, other than the function "resetGame", expects it to be defined as a global variable, and as a copy of "EMPTY_GAME" with varying levels of defined values.
         * A move that would put the marker off of the grid leads to the marker being put back where it was AND still triggers a touch inside the cell the marker started in (and was then put back onto). */

        /* COMMON ASSUMPTIONS.
         * I found myself writing some of the same assumptions repeatedly, so I decided to write shorthand identifiers for them and just use the identifier to reference the concept in the assumptions section.
         * #A = The function "setupGame" was already called.
         * #B = "move" is an object composed of at least "direction" and "distance" members, where "direction" contains a value belonging to the "DIRECTIONS" array and "distance" contains a value belonging to the "DISTANCES" array.
         * #C = "position" is an object composed of at least "row" and "column" members, where "row" and "column" are both whole numbers. */

        "use strict"; //Strict mode used for better debugging and coding standards.

        google.charts.load('current', {'packages': ['corechart', 'bar']});
        google.charts.setOnLoadCallback(drawChart);

        function drawChart(averageTotalMoveForNotHyper = 0, averageTotalMovesForHyper = 0) {
            let data = new google.visualization.DataTable();

            data.addColumn('string', 'Hyper or Not');
            data.addColumn('number', 'Average Total Moves');

            data.addRows(
                [
                    [
                        "Not Hyper",
                        averageTotalMoveForNotHyper
                    ],
                    [
                        "Hyper",
                        averageTotalMovesForHyper
                    ]
                ]
            );

            new google.charts.Bar(document.getElementById('graph')).draw(data);
        }

        //CONSTANTS.
        //There are so many constants because these are the things I would put in a config file for easy tweaking of the parameters of the program.

        //These are basically type definitions, they get copied into objects that are to take on this form of object later.
        const EMPTY_GRID = [];
        const EMPTY_ROW = [];
        const EMPTY_COLUMN = 0;
        const EMPTY_POSITION = {
            "row": undefined,
            "column": undefined
        };
        const EMPTY_MOVE = {
            "direction": undefined,
            "distance": undefined
        };
        const EMPTY_GAME = {
            "parameters": {
                "hyper": undefined,
                "speed": undefined,
                "rowQuantity": undefined,
                "columnQuantity": undefined
            },
            "grid": undefined,
            "marker": {
                "position": {
                    "row": undefined,
                    "column": undefined
                }
            },
            "touches": 0,
            "results": {
                "maximumTouches": undefined,
                "minimumTouches": undefined,
                "averageTouchesPerCell": undefined,
                "outcome": undefined,
                "totalTouches": undefined
            }
        };
        const EMPTY_EXPERIMENT = {
            "trials": [],
            "parameters": {
                "quantityTrials": {
                    "notHyper": undefined,
                    "hyper": undefined
                }
            }
        };
        const EMPTY_TRIAL = {
            "independentVariableValue": undefined,
            "dependentVariableValue": undefined,
            "game": undefined
        };

        //Grid specifications.
        const DEFAULT_ROW_QUANTITY = 9;
        const DEFAULT_COLUMN_QUANTITY = 9;

        const MAXIMUM_TOUCHES_ALLOWED = 1000000;

        const DEFAULT_SPEED = 100;

        //ENUMS.
        //Direction Enum.
        const DIRECTION_LEFT = 0;
        const DIRECTION_UP = 1;
        const DIRECTION_RIGHT = 2;
        const DIRECTION_DOWN = 3;
        const DIRECTIONS = [DIRECTION_LEFT, DIRECTION_UP, DIRECTION_RIGHT, DIRECTION_DOWN];
        const DIRECTION_QUANTITY = DIRECTIONS.length;

        //Distance Enum.
        const DISTANCE_ZERO = 0;
        const DISTANCE_ONE = 1;
        const DISTANCE_TWO = 2;
        const DISTANCES = [DISTANCE_ZERO, DISTANCE_ONE, DISTANCE_TWO];
        const DISTANCE_QUANTITY = DISTANCES.length;

        //End Game Enum.
        const GAME_SUCCESS = true;
        const GAME_FAILURE = false;

        //End Game Messages.
        const GAME_SUCCESS_MESSAGE = "The marker is now in the correct position.";
        const GAME_FAILURE_MESSAGE = "The game surpassed the maximum amount of turns allowed and failed to push the marker to the correct position.";

        //The global experiment object.
        let experiment = deepCopy(EMPTY_EXPERIMENT);

        //The global game object.
        let game = undefined;

        //The global interval for running the game.
        let interval = undefined;

        resetGame();

        /* Purpose: Entry point to the rest of the logic of this game, it is triggered when the user clicks the "Play New Game" button.
         * Inputs: None.
         * Output: None.
         * Assumptions: None. */
        function playNewGame() {
            return new Promise(
                (resolve, reject) => {
                    if (validParameters()) {
                        resetGame();
                        collectParameters();
                        buildGrid();
                        setupGame();
                        playGame().then(
                            () => {
                                calculateResults();
                                printResults();

                                let trial = deepCopy(EMPTY_TRIAL);
                                trial.independentVariableValue = "Not Hyper";
                                trial.dependentVariableValue = game.results.totalTouches;
                                trial.game = deepCopy(game);
                                experiment.trials.push(trial);
                                resolve();
                            },
                            (error) => {
                                reject(error);
                            }
                        );
                    }
                }
            );
        }

        /* Purpose: Determine if the parameters the user entered are valid.
         * Inputs: None.
         * Output: A boolean indicating whether the parameters the user entered are valid.
         * Assumptions: None. */
        function validParameters() {
            let inputErrors = [];
            try {
                let potentialSpeedParameter = getSpeedParameter();
                let potentialRowQuantityParameter = getRowQuantityParameter();
                let potentialColumnQuantityParameter = getColumnQuantityParameter();

                if (potentialSpeedParameter <= 0) {
                    inputErrors.push("Speed must be an integer greater than 0!");
                }
                if (potentialRowQuantityParameter < 5 || potentialRowQuantityParameter > 20) {
                    inputErrors.push("Row Quantity must be an integer greater than 4 and less than 21!");
                }
                if (potentialColumnQuantityParameter < 5 || potentialColumnQuantityParameter > 20) {
                    inputErrors.push("Column Quantity must be an integer greater than 4 and less than 21!");
                }

                if (inputErrors.length > 0) {
                    let errorMessage = "Could not play a new game, your parameters have the following issues:\n- " + inputErrors.join("\n- ");

                    alert(errorMessage);

                    return false;
                } else {
                    return true;
                }
            } catch (e) {
                alert("Your parameters are invalid!");
            }
        }

        /* Purpose: Gathers all the parameters and stores them in the game.parameters object.
         * Inputs: None.
         * Output: None.
         * Assumptions: The game object has been populated with a deep copy of "EMPTY_GAME". */
        function collectParameters() {
            game.parameters.hyper = getHyperParameter();
            game.parameters.speed = getSpeedParameter();
            game.parameters.rowQuantity = getRowQuantityParameter();
            game.parameters.columnQuantity = getColumnQuantityParameter();
        }

        function getHyperParameter() {
            return $("#hyper").is(":checked");
        }

        /* Purpose: Gets the value in the speed input box.
         * Inputs: None.
         * Output: The value in the speed input box.
         * Assumptions: The value returned from getInputValue is a number. */
        function getSpeedParameter() {
            return parseInt(getInputValue("speed"));
        }

        /* Purpose: Gets the value in the row quantity input box.
         * Inputs: None.
         * Output: The value in the row quantity input box.
         * Assumptions: The value returned from getInputValue is a number. */
        function getRowQuantityParameter() {
            return parseInt(getInputValue("row-quantity"));
        }

        /* Purpose: Gets the value in the column quantity input box.
         * Inputs: None.
         * Output: The value in the column quantity input box.
         * Assumptions: The value returned from getInputValue is a number. */
        function getColumnQuantityParameter() {
            return parseInt(getInputValue("column-quantity"));
        }

        /* Purpose: Gets the value in an HTML element with the provided id.
         * Inputs: "id" - The id of the HTML element with which to fetch a value from.
         * Output: The value of the HTML element.
         * Assumptions: An HTML element with the provided id exists and has a value. */
        function getInputValue(id) {
            let elementValue = document.getElementById(id).value;

            if (elementValue) {
                return elementValue;
            } else {
                throw new Error("Your parameters are invalid!");
            }
        }

        /* Purpose:To construct the graphical grid and put it on the page.
         * Inputs: None.
         * Output: None.
         * Assumptions: An HTML element with the id "game-board-wrapper" exists. The function "collectParameters" has already executed successfully. */
        function buildGrid() {
            let content = "<div id=\"game-board\">";
            for (let i = 0; i < game.parameters.rowQuantity; i++) {
                content += "<div id=\"row-" + i + "\" class=\"row\">";

                for (let j = 0; j < game.parameters.columnQuantity; j++) {
                    let columnClass = "column-" + (i % 2 === 0 ? "even" : "odd") + "-" + (j % 2 === 0 ? "even" : "odd");

                    content += "<div id=\"column-" + i + "-" + j + "\" class=\"column " + columnClass + "\"><div class='marker-off'><p class='cell-content'>0</p></div></div>";
                }

                content += "</div>";
            }
            content += "</div>";

            document.getElementById("game-board-wrapper").innerHTML = content;
        }

        /* Purpose: Ensures the game always starts as a fresh game with no previous values carried over.
         * Inputs: None.
         * Output: None.
         * Assumptions: None. */
        function resetGame() {
            game = deepCopy(EMPTY_GAME);
            resetInterval();
        }

        /* Purpose: Clears the interval so that each time you start a new game the previous interval isn't carried over.
         * Inputs: None.
         * Output: None
         * Assumptions: None. */
        function resetInterval() {
            if (interval) {
                clearInterval(interval);
            }
        }

        /* Purpose: Takes an object and copies it to a brand new object to avoid passing by reference. This is accomplished by turning the object into a JSON string and then bringing it back to an object, thereby removing any references to a previous object.
         * Inputs: "object" - The entity you wish to deep copy.
         * Output: a completely separate copy of "object".
         * Assumptions: "object" is not a self-referential object, nor an object which leads to circular references. Failure to adhere to these assumptions leads to JSON.stringify failing. */
        function deepCopy(object) {
            return JSON.parse(JSON.stringify(object));
        }

        /* Purpose: Preforms initial setup of the game by creating the grid and placing the marker in the starting position.
         * Inputs: None.
         * Output: None.
         * Assumptions: The function "resetGame" was already called. */
        function setupGame() {
            createGrid(game.parameters.rowQuantity, game.parameters.columnQuantity);
            resetResults();
            placeMarkerAndRecordTouchAt(0, 0);
        }

        /* Purpose: Resets the results table to the initial settings of the first frame of a running game.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function resetResults() {
            document.getElementById("results").innerHTML = `
                    <table id="results-table" class="center-me" align="center">
                        <tr>
                            <th>Type</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>Outcome</td>
                            <td>Game is running...</td>
                        </tr>
                        <tr>
                            <td>Maximum Touches in a Cell</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>Minimum Touches in a Cell</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>Average Touches per Cell</td>
                            <td>` + (1 / (game.parameters.rowQuantity * game.parameters.columnQuantity)).toFixed(2) + `</td>
                        </tr>
                        <tr>
                            <td>Total Touches</td>
                            <td>1</td>
                        </tr>
                    </table>
            `;
        }

        /* Purpose: Creates the grid for the game.
         * Inputs:
         * • "rowQuantity" - The number of rows to put in this grid.
         * • "columnQuantity" - The number of columns to put in this grid.
         * Output: None.
         * Assumptions: Inputs are all natural numbers. */
        function createGrid(rowQuantity, columnQuantity) {
            resetGrid();
            addRowsAndColumnsToGrid(rowQuantity, columnQuantity);
        }

        /* Purpose: Clears the game's grid object to ensure there is no left over values from a previous game.
         * Inputs: None.
         * Output: None.
         * Assumptions: None. */
        function resetGrid() {
            game.grid = deepCopy(EMPTY_GRID);
        }

        /* Purpose: Adds the rows and columns to the game's grid object.
         * Inputs:
         * • "rowQuantity" - The number of rows to put in this grid.
         * • "columnQuantity" - The number of columns to put in this grid.
         * Output: None.
         * Assumptions: Inputs are all natural numbers. */
        function addRowsAndColumnsToGrid(rowQuantity, columnQuantity) {
            for (let rowIndex = 0; rowIndex < rowQuantity; rowIndex++) {
                addNewRow();
                addColumnsToRow(rowIndex, columnQuantity);
            }
        }

        /* Purpose: Adds a new row to the game's grid object.
         * Inputs: None.
         * Output: None.
         * Assumptions: "game.grid" is an array. */
        function addNewRow() {
            game.grid.push(deepCopy(EMPTY_ROW));
        }

        /* Purpose: Adds all the columns to the game's grid object's current row.
         * Inputs:
         * • "rowIndex" - The current row of the grid which we are filling with columns.
         * • "columnQuantity" - The number of columns to put in this row.
         * Output: None.
         * Assumptions: "rowIndex" is a whole number, "columnQuantity" is a natural number. */
        function addColumnsToRow(rowIndex, columnQuantity) {
            for (let columnIndex = 0; columnIndex < columnQuantity; columnIndex++) {
                addNewColumnToRow(rowIndex);
            }
        }

        /* Purpose: Adds a new column to the game's grid object's current row.
         * Inputs: "rowIndex" - The current row of the grid which we are adding a column to.
         * Output: None.
         * Assumptions: "rowIndex" is a whole number, "game.grid[rowIndex]" is an array. */
        function addNewColumnToRow(rowIndex) {
            game.grid[rowIndex].push(deepCopy(EMPTY_COLUMN));
        }

        /* Purpose: Places the marker at the provided row and column, and records the touch it creates in being placed.
         * Inputs:
         * • "row" - The row to place the marker and record the touch at.
         * • "column" - The column to place the marker and record the touch at.
         * Output: None.
         * Assumptions: Inputs are all whole numbers. */
        function placeMarkerAndRecordTouchAt(row, column) {
            placeMarkerAt(row, column);
            recordTouchAt(row, column);
        }

        /* Purpose: Places the marker at the provided row and column.
         * Inputs:
         * • "row" - The row to place the marker at.
         * • "column" - The column to place the marker at.
         * Output: None.
         * Assumptions: Inputs are all whole numbers. */
        function placeMarkerAt(row, column) {
            updateMarkerOnGrid(row, column);

            game.marker.position.row = row;
            game.marker.position.column = column;
        }

        /* Purpose: Updates the markers graphical position on the grid.
         * Inputs:
         * • "row" - The row to update the marker's position to.
         * • "column" - The column to update the marker's position to.
         * Output: None.
         * Assumptions: */
        function updateMarkerOnGrid(row, column) {
            removeMarkerFromGrid();
            placeMarkerOnGridAt(row, column);
        }

        /* Purpose: Deletes the marker from the graphical grid.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. An HTML element with id "column-i-j" exists where i and j are the markers current row and column, respectively. Marker is actually on the grid. */
        function removeMarkerFromGrid() {
            if (markerIsOnGrid()) {
                document.getElementById("column-" + game.marker.position.row + "-" + game.marker.position.column).innerHTML = "<div class=\"marker-off\"><p class=\"cell-content\">" + game.grid[game.marker.position.row][game.marker.position.column] + "</p></div>";
            }
        }

        /* Purpose: Determine if the marker is currently on the graphical grid.
         * Inputs: None.
         * Output: A boolean indicating whether the marker is currently on the graphical grid.
         * Assumptions: #A. */
        function markerIsOnGrid() {
            return game.marker.position.row !== undefined && game.marker.position.column !== undefined;
        }

        /* Purpose: Put the marker on the graphical grid at the provided locaiton.
         * Inputs:
         * • "row" - The row to place the marker at.
         * • "column" - The column to place the marker at.
         * Output: None.
         * Assumptions: #A. An HTML element with id "column-i-j" exists where i and j are the provided row and column, respectively. */
        function placeMarkerOnGridAt(row, column) {
            document.getElementById("column-" + row + "-" + column).innerHTML = "<div id=\"marker\"><p class='cell-content'>" + (game.grid[row][column] + 1) + "</p></div>";
        }

        /* Purpose: Records the touch at the provided row and column, and also in the running total.
         * Inputs:
         * • "row" - The row to record the touch at.
         * • "column" - The column to record the touch at.
         * Output: None.
         * Assumptions: Inputs are all whole numbers. */
        function recordTouchAt(row, column) {
            incrementTotalTouches();
            incrementTouchCountAt(row, column);
        }

        /* Purpose: Increments the game's total touches.
         * Inputs: None.
         * Output: None.
         * Assumptions: "game.touches" is an integer. */
        function incrementTotalTouches() {
            game.touches++;
        }

        /* Purpose: Increments the game's grid object's touch count at the provided row and column.
         * Inputs:
         * • "row" - The row to record the touch at.
         * • "column" - The column to record the touch at.
         * Output: None.
         * Assumptions: Inputs are all whole numbers and "game.grid[row][column] is an integer. */
        function incrementTouchCountAt(row, column) {
            game.grid[row][column]++;
        }

        /* Purpose: Plays the game based on the interval the user entered under the "speed" parameter.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function playGame() {
            //I use a promise here because I am running a process for an indefinite amount of time and the statements following it in the calling function need to wait until completion.
            //This is not traditional JavaScript because it is now an asynchronous process and as such, I need a way to signify when the async code is completed. This is the purpose of the promise.
            return new Promise(
                (resolve, reject) => {
                    interval = setInterval(
                        () => {
                            if (shouldContinuePlayingGame()) {
                                continuePlayingGame();
                            } else {
                                clearInterval(interval);
                                resolve();
                            }
                        },
                        game.parameters.speed
                    )
                }
            )
        }

        /* Purpose: Determines whether the game is over or if it should continue playing. This is determined by checking if the win condition (marker is in winning position) or lose condition (too many moves) has been met.
         * Inputs: None.
         * Output: A boolean indicating whether the game should continue playing or not.
         * Assumptions: #A. */
        function shouldContinuePlayingGame() {
            return !gameIsWon() && !gameIsBeyondMaximumTouches();
        }

        /* Purpose: Determines whether the game has been won or not.
         * Inputs: None.
         * Output: A boolean indicating whether the game has been won or not.
         * Assumptions: #A. */
        function gameIsWon() {
            return markerIsInWinningPosition();
        }

        /* Purpose: Determines whether the marker is in the winning position or not.
         * Inputs: None.
         * Output: A boolean indicating whether the marker is in the winning position or not.
         * Assumptions: #A. */
        function markerIsInWinningPosition() {
            return markerIsInWinningRow() && markerIsInWinningColumn();
        }

        /* Purpose: Determines whether the marker is in the winning row or not.
         * Inputs: None.
         * Output: A boolean indicating whether the marker is in the winning row or not.
         * Assumptions: #A. */
        function markerIsInWinningRow() {
            return game.marker.position.row === 4;
        }

        /* Purpose: Determines whether the marker is in the winning column or not.
         * Inputs: None.
         * Output: A boolean indicating whether the marker is in the winning column or not.
         * Assumptions: #A. */
        function markerIsInWinningColumn() {
            return game.marker.position.column === 4;
        }

        /* Purpose: Determines whether the game has surpassed the maximum amount of touches or not.
         * Inputs: None.
         * Output: A boolean indicating whether the game has surpassed the maximum amount of touches or not.
         * Assumptions: #A. */
        function gameIsBeyondMaximumTouches() {
            return game.touches >= MAXIMUM_TOUCHES_ALLOWED;
        }

        /* Purpose: Run the game through another iteration. Each iteration is composed of generating a move, recording the marker's original position, determining if the generated move is valid, and moving the marker accordingly.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function continuePlayingGame() {
            let move = generateRandomMove();
            let originalMarkerLocation = deepCopy(game.marker.position);

            if (!game.parameters.hyper) {
                if (thisMoveDoesNotPutMarkerOutsideOfGrid(move)) {
                    placeMarkerAtPositionFromMove(move);
                    updateLastMoveDescriptionTable(move, true);
                } else {
                    placeMarkerAtOriginalLocation(originalMarkerLocation);
                    updateLastMoveDescriptionTable(move, false);
                }
            } else {
                placeMarkerAtHyperPositionFromMove(move);
                updateLastMoveDescriptionTable(move, false);
            }

            calculateRunningResults();
            printRunningResults();
        }

        /* Purpose: Update the last move description table with details about the last move.
         * Inputs:
         * • "move" - The move object that was just applied on the marker.
         * • "isValidMove" - Whether or not that move would've put the marker outside of the grid.
         * Output: None.
         * Assumptions: #B. An HTML element with id "last-move-description-wrapper" exists. */
        function updateLastMoveDescriptionTable(move, isValidMove) {
            document.getElementById("last-move-description-wrapper").innerHTML = `
                 <table id="last-move-description-table" class="center-me" align="center">
                    <tr>
                        <th>Statistic</th>
                        <th>Value</th>
                    </tr>
                    <tr>
                        <td>Direction</td>
                        <td>` + getMoveDirection(move) + `</td>
                    </tr>
                    <tr>
                        <td>Distance</td>
                        <td>` + getMoveDistance(move) + `</td>
                    </tr>
                    <tr>
                        <td>Valid?</td>
                        <td>` + isValidMove + `</td>
                    </tr>
                </table>
            `;
        }

        /* Purpose:
         * Inputs:
         * Output:
         * Assumptions: */
        function getMoveDirection(move) {
            switch (move.direction) {
                case DIRECTION_LEFT:
                    return "Left";
                    break;
                case DIRECTION_UP:
                    return "Up";
                    break;
                case DIRECTION_RIGHT:
                    return "Right";
                    break;
                case DIRECTION_DOWN:
                    return "Down";
                    break;
            }
        }

        /* Purpose: Creates a random move to apply to the marker.
         * Inputs: None.
         * Output: A randomly generated move.
         * Assumptions: None. */
        function generateRandomMove() {
            let move = deepCopy(EMPTY_MOVE);

            move.direction = generateRandomDirection();
            move.distance = generateRandomDistance();

            return move;
        }

        /* Purpose: Selects a random direction from the direction array.
         * Inputs: None.
         * Output: A randomly chosen direction from the direction array.
         * Assumptions: None. */
        function generateRandomDirection() {
            return DIRECTIONS[getRandomIntegerBetween(0, DIRECTION_QUANTITY)];
        }

        /* Purpose: Creates a random integer between two values.
         * Inputs:
         * • "lowerBound" - A number indicating the inclusive lower bound for the range of random integers to generate.
         * • "upperBound" - A number indicating the inclusive upper bound for the range of random integers to generate.
         * Output: A random integer that falls between "lowerBound" and "upperBound" inclusive.
         * Assumptions: Inputs are all integers. "lowerBound" <= "upperBound". */
        function getRandomIntegerBetween(lowerBound, upperBound) {
            return lowerBound + Math.floor(Math.random() * upperBound)
        }

        /* Purpose: Selects a random distance from the distance array.
         * Inputs: None.
         * Output: A randomly chosen distance from the distance array.
         * Assumptions: None. */
        function generateRandomDistance() {
            return DISTANCES[getRandomIntegerBetween(0, DISTANCE_QUANTITY)];
        }

        /* Purpose: Determines whether the provided move would put the marker outside of the grid or not. This is accomplished by getting the position the marker would be in if the provided move were applied, then checking if that position is in the grid still.
         * Inputs: "move" - The move object containing both a direction and a distance.
         * Output: A boolean indicating whether the provided move would put the marker outside of the grid or not.
         * Assumptions: #A. #B. */
        function thisMoveDoesNotPutMarkerOutsideOfGrid(move) {
            let potentialNewMarkerPosition = getMarkerPositionAfterThisMove(move);
            return positionIsWithinGrid(potentialNewMarkerPosition);
        }

        /* Purpose: Determines whether the provided position is within the grid or not. This is accomplished by checking all four bounds of the gird for any breaches.
         * Inputs: "position" - The position object containing both a row and a column.
         * Output: A boolean indicating whether the provided position is within the grid.
         * Assumptions: #C. */
        function positionIsWithinGrid(position) {
            return positionIsWithinLeftBound(position) && positionIsWithinTopBound(position) && positionIsWithinRightBound(position) && positionIsWithinBottomBound(position); //If the position is within all four bounds of the grid, return true, else return false.
        }

        /* Purpose: Determines whether the provided position is within the left bound of the grid.
         * Inputs: "position" - The position object containing both a row and a column.
         * Output: A boolean indicating whether the provided position is within the left bound of the grid.
         * Assumptions: #C. */
        function positionIsWithinLeftBound(position) {
            return position.column >= 0;
        }

        /* Purpose: Determines whether the provided position is within the top bound of the grid.
         * Inputs: "position" - The position object containing both a row and a column.
         * Output: A boolean indicating whether the provided position is within the top bound of the grid.
         * Assumptions: #C. */
        function positionIsWithinTopBound(position) {
            return position.row >= 0;
        }

        /* Purpose: Determines whether the provided position is within the right bound of the grid.
         * Inputs: "position" - The position object containing both a row and a column.
         * Output: A boolean indicating whether the provided position is within the right bound of the grid.
         * Assumptions: #C. */
        function positionIsWithinRightBound(position) {
            return position.column <= game.parameters.columnQuantity - 1;
        }

        /* Purpose: Determines whether the provided position is within the bottom bound of the grid.
         * Inputs: "position" - The position object containing both a row and a column.
         * Output: A boolean indicating whether the provided position is within the bottom bound of the grid.
         * Assumptions: #C. */
        function positionIsWithinBottomBound(position) {
            return position.row <= game.parameters.rowQuantity - 1;
        }

        /* Purpose: Gets the position of the marker after the provided move is applied to it.
         * Inputs: "move" - The move object containing both a direction and a distance.
         * Output: A position object containing a row and column fields which correspond to the position the marker would be in, should the provided move object be applied to it.
         * Assumptions: #A. #B. Failure to adhere to assumption #B leads to the default case of the switch statement executing which leads to an error being thrown. */
        function getMarkerPositionAfterThisMove(move) {
            let markerPositionAfterThisMove = deepCopy(EMPTY_POSITION);

            switch (move.direction) {
                case DIRECTION_LEFT: //If the move direction is up...
                    markerPositionAfterThisMove.row = game.marker.position.row;
                    markerPositionAfterThisMove.column = game.marker.position.column - getMoveDistance(move); //Subtract across the columns to go left.
                    break;
                case DIRECTION_UP: //If the move direction is left...
                    markerPositionAfterThisMove.row = game.marker.position.row - getMoveDistance(move); //Subtract across the rows to go up.
                    markerPositionAfterThisMove.column = game.marker.position.column;
                    break;
                case DIRECTION_RIGHT: //If the move direction is down...
                    markerPositionAfterThisMove.row = game.marker.position.row;
                    markerPositionAfterThisMove.column = game.marker.position.column + getMoveDistance(move); //Advance across the columns to go right.
                    break;
                case DIRECTION_DOWN: //If the move direction is right...
                    markerPositionAfterThisMove.row = game.marker.position.row + getMoveDistance(move); //Advance across the rows to go down.
                    markerPositionAfterThisMove.column = game.marker.position.column;
                    break;
                default:
                    throw new Error("Unrecognized move direction encountered: \"" + move.direction + "\".");
            }

            return markerPositionAfterThisMove;
        }

        function getMarkerPositionAfterThisHyperMove(move) {
            let markerPositionAfterThisMove = deepCopy(EMPTY_POSITION);

            switch (move.direction) {
                case DIRECTION_LEFT: //If the move direction is up...
                    markerPositionAfterThisMove.row = game.marker.position.row;
                    if (game.marker.position.column - getMoveDistance(move) >= 0) {
                        markerPositionAfterThisMove.column = game.marker.position.column - getMoveDistance(move); //Subtract across the columns to go left.
                    } else {
                        markerPositionAfterThisMove.column = game.parameters.columnQuantity - Math.abs(game.marker.position.column - getMoveDistance(move));
                    }
                    break;
                case DIRECTION_UP: //If the move direction is left...
                    if (game.marker.position.row - getMoveDistance(move) >= 0) {
                        markerPositionAfterThisMove.row = game.marker.position.row - getMoveDistance(move); //Subtract across the rows to go up.
                    } else {
                        markerPositionAfterThisMove.row = game.parameters.rowQuantity - Math.abs(game.marker.position.row - getMoveDistance(move));
                    }
                    markerPositionAfterThisMove.column = game.marker.position.column;
                    break;
                case DIRECTION_RIGHT: //If the move direction is down...
                    markerPositionAfterThisMove.row = game.marker.position.row;
                    if (game.marker.position.column + getMoveDistance(move) < game.parameters.columnQuantity) {
                        markerPositionAfterThisMove.column = game.marker.position.column + getMoveDistance(move); //Advance across the columns to go right.
                    } else {
                        markerPositionAfterThisMove.column = game.marker.position.column + getMoveDistance(move) - game.parameters.columnQuantity;
                    }
                    break;
                case DIRECTION_DOWN: //If the move direction is right...
                    if (game.marker.position.row + getMoveDistance(move) < game.parameters.rowQuantity) {
                        markerPositionAfterThisMove.row = game.marker.position.row + getMoveDistance(move); //Advance across the rows to go down.
                    } else {
                        markerPositionAfterThisMove.row = game.marker.position.row + getMoveDistance(move) - game.parameters.rowQuantity;
                    }
                    markerPositionAfterThisMove.column = game.marker.position.column;
                    break;
                default:
                    throw new Error("Unrecognized move direction encountered: \"" + move.direction + "\".");
            }

            return markerPositionAfterThisMove;
        }

        /* Purpose: Gets the distance as a number represented in the provided move object.
         * Inputs: "move" - The move object containing both a direction and a distance.
         * Output: The distance as an integer that the move object contains.
         * Assumptions: #B. Failure to adhere to assumption #B leads to the default case of the switch statement executing which leads to an error being thrown. */
        function getMoveDistance(move) {
            let distance = undefined;

            switch (move.distance) {
                case DISTANCE_ZERO:
                    distance = 0;
                    break;
                case DISTANCE_ONE:
                    distance = 1;
                    break;
                case DISTANCE_TWO:
                    distance = 2;
                    break;
                default:
                    throw new Error("Unrecognized move distance encountered: \"" + move.distance + "\".");
            }

            return distance;
        }

        /* Purpose: Puts the marker at its new position after the provided move is applied to it.
         * Inputs: "move" - The move object containing both a direction and a distance.
         * Output: None.
         * Assumptions: #B. The function "getMarkerPositionAfterThisMove" returns a valid position object, resembling the object described in #C. */
        function placeMarkerAtPositionFromMove(move) {
            let newMarkerPosition = getMarkerPositionAfterThisMove(move);
            placeMarkerAndRecordTouchAt(newMarkerPosition.row, newMarkerPosition.column);
        }

        function placeMarkerAtHyperPositionFromMove(move) {
            let newMarkerPosition = getMarkerPositionAfterThisHyperMove(move);
            placeMarkerAndRecordTouchAt(newMarkerPosition.row, newMarkerPosition.column);
        }

        /* Purpose: Puts the marker at its original position because the move generated earlier would put the marker off the grid.
         * Inputs: "originalMarkerLocation" - A position object containing the original position of the marker before a move is executed.
         * Output: None.
         * Assumptions: "originalMarkerLocation" resembles the object described in #C. */
        function placeMarkerAtOriginalLocation(originalMarkerLocation) {
            placeMarkerAndRecordTouchAt(originalMarkerLocation.row, originalMarkerLocation.column);
        }

        /* Purpose: Calculates the results of the game and stores them in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateResults() {
            calculateOutcome();
            calculateMaximumTouches();
            calculateMinimumTouches();
            calculateAverageTouchesPerCell();
            calculateTotalTouches();
        }

        /* Purpose: Update the results table while the game is running.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. An HTML element with id "results" exists. */
        function printRunningResults() {
            document.getElementById("results").innerHTML = `
                    <table id="results-table" class="center-me" align="center">
                        <tr>
                            <th>Type</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>Outcome</td>
                            <td>Game is running...</td>
                        </tr>
                        <tr>
                            <td>Maximum Touches in a Cell</td>
                            <td>` + game.results.maximumTouches + `</td>
                        </tr>
                        <tr>
                            <td>Minimum Touches in a Cell</td>
                            <td>` + game.results.minimumTouches + `</td>
                        </tr>
                        <tr>
                            <td>Average Touches per Cell</td>
                            <td>` + game.results.averageTouchesPerCell + `</td>
                        </tr>
                        <tr>
                            <td>Total Touches</td>
                            <td>` + game.results.totalTouches + `</td>
                        </tr>
                    </table>
            `;
        }

        /* Purpose: To calculate the running results (does not calculate the game's outcome, because it's still running).
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateRunningResults() {
            calculateMaximumTouches();
            calculateMinimumTouches();
            calculateAverageTouchesPerCell();
            calculateTotalTouches();
        }

        /* Purpose: Calculates the outcome of the game and stores it in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. The game has either reached a winning condition or has surpassed the maximum amount of touches allowed. Failure to adhere to the previous assumption leads to an error being thrown. */
        function calculateOutcome() {
            if (gameIsWon()) {
                game.results.outcome = GAME_SUCCESS;
            } else if (gameIsBeyondMaximumTouches()) {
                game.results.outcome = GAME_FAILURE;
            } else {
                throw new Error("Unexpected end of game encountered.");
            }
        }

        /* Purpose: Calculates the maximum touches of the game and stores it in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateMaximumTouches() {
            game.results.maximumTouches = findMaximumTouchesInGrid();
        }

        /* Purpose: Preforms the actual calculation of which cell had the most touches.
         * Inputs: None.
         * Output: The quantity of touches in the cell that has the most touches.
         * Assumptions: #A. */
        function findMaximumTouchesInGrid() {
            let maximumTouchedInGrid = 0;

            game.grid.forEach( //For each row in the grid...
                (row) => {
                    row.forEach( //For each column in this row...
                        (touchesInCell) => {
                            if (touchesInCell > maximumTouchedInGrid) { //If the touches in this cell is more than the maximum recorded...
                                maximumTouchedInGrid = touchesInCell; //The touches in this cell is the maximum, record that.
                            }
                        }
                    );
                }
            );

            return maximumTouchedInGrid;
        }

        /* Purpose: Calculates the minimum touches of the game and stores it in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateMinimumTouches() {
            game.results.minimumTouches = findMinimumTouchesInGrid();
        }

        /* Purpose: Preforms the actual calculation of which cell had the least touches.
         * Inputs: None.
         * Output: The quantity of touches in the cell that has the least touches.
         * Assumptions: #A. */
        function findMinimumTouchesInGrid() {
            let minimumTouchedInGrid = MAXIMUM_TOUCHES_ALLOWED;

            game.grid.forEach( //For each row in the grid...
                (row) => {
                    row.forEach( //For each column in this row...
                        (touchesInCell) => {
                            if (touchesInCell < minimumTouchedInGrid) { //If the touches in this cell is less than the minimum recorded...
                                minimumTouchedInGrid = touchesInCell; //The touches in this cell is the minimum, record that.
                            }
                        }
                    );
                }
            );

            return minimumTouchedInGrid;
        }

        /* Purpose: Calculates the average touches per cell of the game and stores it in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateAverageTouchesPerCell() {
            game.results.averageTouchesPerCell = findAverageTouchesPerCellInGrid();
        }

        /* Purpose: Preforms the actual calculation of the average touches per cell.
         * Inputs: None.
         * Output: The average quantity of touches across all cells in the grid as a decimal precise to 2 decimal places.
         * Assumptions: #A. "game.parameters.rowQuantity * game.parameters.columnQuantity" != 0. */
        function findAverageTouchesPerCellInGrid() {
            let totalTouches = 0;

            game.grid.forEach( //For each row in the grid...
                (row) => {
                    row.forEach( //For each column in this row...
                        (touchesInCell) => {
                            totalTouches += touchesInCell; //Add the touches in this cell to the total touches recorded so far.
                        }
                    );
                }
            );

            return (totalTouches / (game.parameters.rowQuantity * game.parameters.columnQuantity)).toFixed(2); //The average touches per cell is the total touches across all cells divided by how many cells there are.
        }

        /* Purpose: Calculates the total touches of the game and stores it in the game object.
         * Inputs: None.
         * Output: None.
         * Assumptions: #A. */
        function calculateTotalTouches() {
            game.results.totalTouches = game.touches;
        }

        /* Purpose: Writes the results of the game to the document inside the results wrapper.
         * Inputs: None.
         * Output: None.
         * Assumptions: An HTML element with id "results" exists. If the game has not been run these values will all be undefined. */
        function printResults() {
            console.log(game.grid)
            document.getElementById("results").innerHTML = `
                    <table id="results-table" class="center-me" align="center">
                        <tr>
                            <th>Type</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>Outcome</td>
                            <td>` + (game.results.outcome === GAME_SUCCESS ? GAME_SUCCESS_MESSAGE : GAME_FAILURE_MESSAGE) + `</td>
                        </tr>
                        <tr>
                            <td>Maximum Touches in a Cell</td>
                            <td>` + game.results.maximumTouches + `</td>
                        </tr>
                        <tr>
                            <td>Minimum Touches in a Cell</td>
                            <td>` + game.results.minimumTouches + `</td>
                        </tr>
                        <tr>
                            <td>Average Touches per Cell</td>
                            <td>` + game.results.averageTouchesPerCell + `</td>
                        </tr>
                        <tr>
                            <td>Total Touches</td>
                            <td>` + game.results.totalTouches + `</td>
                        </tr>
                    </table>
            `;
        }

        function doExperiment() {
            playNewGame().then(
                () => {
                    if (experiment.trials.length < 1000) {
                        doExperiment();

                        let x = 0;
                        experiment.trials.forEach(
                            (trial) => {
                                x += trial.dependentVariableValue;
                            }
                        );

                        console.log(x);
                        console.log(experiment.trials.length);
                        console.log(x / experiment.trials.length);

                        drawChart(x / experiment.trials.length, 0);
                    } else {
                        //TODO
                    }
                }
            );
        }
    </script>
</head>
<body>
<div id="parameters-divider" class="divider">
    <div id="parameters-wrapper" class="panel">
        <h2 id="parameters-panel-title" class="panel-title">Parameters</h2>
        <table id="parameters-table" class="center-me" align="center">
            <tr>
                <th>Parameter</th>
                <th>Value</th>
            </tr>
            <tr>
                <td>Hyper</td>
                <td>
                    <input id="hyper" class="parameter-input" type="checkbox"/>
                </td>
            </tr>
            <tr>
                <td>Speed</td>
                <td>
                    <input id="speed" class="parameter-input" type="number" min="1" value="250"/>
                </td>
            </tr>
            <tr>
                <td>Row Quantity</td>
                <td>
                    <input id="row-quantity" class="parameter-input" type="number" min="5" max="20" value="9"/>
                </td>
            </tr>
            <tr>
                <td>Column Quantity</td>
                <td>
                    <input id="column-quantity" class="parameter-input" type="number" min="5" max="20" value="9"/>
                </td>
            </tr>
        </table>
        <button id="play-new-game-button" class="center-me" onClick="playNewGame();">Play New Game</button>
    </div>
</div>

<div id="game-divider" class="divider">
    <div id="game-wrapper" class="panel">
        <h2 id="game-panel-title" class="panel-title">Game</h2>
        <div id="game-board-wrapper"></div>
        <h3 id="last-move-description-subtitle" class="panel-subtitle">Last Move</h3>
        <div id="last-move-description-wrapper">
            <table id="last-move-description-table" class="center-me" align="center">
                <tr>
                    <th>Statistic</th>
                    <th>Value</th>
                </tr>
                <tr>
                    <td>Direction</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>Distance</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>Valid?</td>
                    <td>-</td>
                </tr>
            </table>
        </div>
    </div>
</div>

<div id="results-divider" class="divider">
    <div id="results-wrapper" class="panel">
        <h2 id="results-panel-title" class="panel-title">Results</h2>
        <div id="results">
            <table id="results-table" class="center-me" align="center">
                <tr>
                    <th>Type</th>
                    <th>Value</th>
                </tr>
                <tr>
                    <td>Outcome</td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum Touches in a Cell</td>
                    <td></td>
                </tr>
                <tr>
                    <td>Minimum Touches in a Cell</td>
                    <td></td>
                </tr>
                <tr>
                    <td>Average Touches per Cell</td>
                    <td></td>
                </tr>
                <tr>
                    <td>Total Touches</td>
                    <td></td>
                </tr>
            </table>
        </div>
    </div>
</div>

<div id="graph"></div>
<button onclick="drawChart()">drawChart</button>
<button onclick="doExperiment()">Do Experiment</button>
</body>
</html>